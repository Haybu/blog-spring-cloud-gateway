= API and Service Rate Limiting with Spring Cloud Gateway
Haytham Mohamed <haythamm@vmware.com>
2021-03-27
:revnumber: {project-version}
:example-caption!:
:chomp: all
ifndef::imagesdir[:imagesdir: images]

One of the imperative architectural concern is to protect API and service endpoints from harmful effects such as denial of service, cascading failure or over utilization of resources. Rate limiting is a technique to control the rate by which an API or a service is consumed. In a distributed system, there would not be better than the option to centralize configuring and managing the rate by which consumers can interact with APIs. Only those requests within a defined rate would make it to the API, any more would raise an HTTP “Many requests” error.


[.thumb]
image::rate-limit-1.svg[scaledwidth=75%]

Spring Cloud Gateway (SCG) is a simple and light weight component, yet an effective way to manage limiting APIs consumption rates. In this blog, I am going to illustrate how simple that could be accomplished using a configuration method. As illustrated in the figure below, the demonstration consists of a frontend and backend services with a Spring Cloud Gateway service in between.

[.thumb]
image::backend-gateway-frontend.svg[scaledwidth=75%]

No code so whatever is needed to hook in the SCG in the architecture. You need to include a Spring Boot Cloud dependency “org.springframework.cloud: spring-cloud-starter-gateway” in a vanilla Spring Boot application and you’re set to go with the appropriate configuration settings.

	Requests received by a SCG from a frontend service could be routed to a backend service based on a configured route definition. A route definition configuration specifies to the gateway how a request should be routed to a backend endpoint. A route configuration usually defines conditions based on information that could be extracted from HTTP requests, such as paths and headers.

For example, the snippet below lists a YAML stanza to configure a predicate to define a condition under which requests should be routed to a backend service. The example below shows that requests should target the backend service when the gateway is hit with “/backend” in the path.  In the configuration, the route is given an identifier and a URI to reach the backend service.

[source, yaml]
----
spring:
  cloud:
    gateway:
      routes:
        - id: route1
          uri: http://localhost:8081
          predicates:
            - Path=/backend
----

“RequestRateLimiter” is one of the many gateway filters offered by SCG out of the box. The implementation determines whether a request is allowed to proceed or has exceeded its limit. The implementation allows to determine a key to manage bucketing up the number of requests made, and Redis could be used to keep track of the counts. A blueprint architecture could be depicted in which a gateway

[.thumb]
image::redis-rate-limiting.svg[scaledwidth=75%]

== Source Code

[source,java]
.Java code from project
----
include::./../../../../backend-service/src/main/java/io/agilehandy/backendservice/RestEndPoint.java[indent=0]
----


== Attributes

.Built-in
asciidoctor-version:: {asciidoctor-version}
safe-mode-name:: {safe-mode-name}
docdir:: {docdir}
docfile:: {docfile}
imagesdir:: {imagesdir}

.Custom
project-version:: {project-version}
sourcedir:: {sourcedir}
endpoint-url:: {endpoint-url}
